<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shys Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-10T12:28:34.284Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>shy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://yoursite.com/2020/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2020-05-10T12:29:40.785Z</published>
    <updated>2020-05-10T12:28:34.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="查找与排序"><a href="#查找与排序" class="headerlink" title="查找与排序"></a>查找与排序</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ol start="2"><li>二分查找，要熟悉迭代与非迭代的写法， 以及对各种边际条件的考量<ol><li>变种：可以使用floor和ceil确定它的上下界<ol><li>当存在大量重复的元素时，floor找的是第一个，ceil找的是第一个。</li><li>当不存在指定的元素时，floor是比其小最大的一个，而ceil是比其大最小的一个。</li><li>算法：先找到对应值，然后再使用二分查找寻找上下界（floor或ceil可作为二分的巩固练习）</li></ol></li><li>二分查找的应用<ol><li>跳表（基于链表的二分查找），redis的有序集合</li><li>二叉搜索树</li><li>有序序列</li><li>快排、归并、堆排</li></ol></li></ol></li><li>JAVA源生查找算法<ol><li>Arrays.binarySearch(list,key);</li><li>Collections.binarySearch(List sList, T key, Comparator C) :根据是否实现了Comparable接口</li></ol></li></ol><h4 id="进阶：基于搜索下标空间的二分和基于值范围的二分：求数组中第n大的元素"><a href="#进阶：基于搜索下标空间的二分和基于值范围的二分：求数组中第n大的元素" class="headerlink" title="进阶：基于搜索下标空间的二分和基于值范围的二分：求数组中第n大的元素"></a>进阶：基于搜索下标空间的二分和基于值范围的二分：求数组中第n大的元素</h4><ol><li>基于值的二分：当重复值较少且值的范围不大时，可以对值域进行二分查找。在这个问题中各方面来看都不是个好方法，不过要知道思路。</li><li>常规的二分思路的应用，在这里是快排partition思想的应用，partition的特点是每次能确定pivot的绝对位置并约束其左右序列的值域，应用在搜索中就是<strong>快速选择算法</strong>，平均时间复杂度O(n)，最坏时间复杂度O(n^2)，一般来说是一种很好的无序查找第k元素的方法。</li></ol><p><strong>快速选择</strong>与三路快排：<a href="https://leetcode-cn.com/problems/wiggle-sort-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/wiggle-sort-ii/</a></p><p>Partition 的两种版本：见LC 215</p><ol><li>交替赋值法</li><li>交换法（不使用while(true)的版本)</li></ol><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ol><li>十种排序算法<ol><li>（最坏、平均、最优）时间复杂度、空间复杂度<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\shy\AppData\Roaming\Typora\typora-user-images\image-20200309194909228.png" alt="image-20200309194909228" title="">                </div>                <div class="image-caption">image-20200309194909228</div>            </figure></li></ol></li><li>排序稳定性的意义<pre><code>1.  对于int[]，确实意义不大；但对于复杂对象，**原始数据的相对关系**可能具有更深的逻辑意义；例如按身高排序，体重的相对关系不应该变化           1.  因此，源生的排序算法，对基本类型是（三路）快排，而复杂类型则是归并排序保证稳定性</code></pre></li><li>哪几种排序支持并行？<ol><li>冒泡排序-》奇偶排序，可并行</li><li>归并排序-&gt;基于msg的分布式系统。比较特殊，在各自的机器内使用快排排好，然后再merge。</li></ol></li></ol><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.zspirytus.com/quicksort/quicksort_repeat.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>分治算法——侧重于分。</p><p>观察快排递归树，二路快排对大于等于是一样的处理，这意味着在重复值较多的情况下，快排递归树会极度不平衡。</p><p>为此而生的就是三路快排,以下是它的parition实现。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\shy\AppData\Roaming\Typora\typora-user-images\image-20200414185401728.png" alt="image-20200414185401728" title="">                </div>                <div class="image-caption">image-20200414185401728</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Key：明晰并维护变量的逻辑含义</span><br><span class="line">&#x2F;&#x2F;left，right都表示partition范围的实边界</span><br><span class="line">public int[] partition(int[] nums, int left, int right) &#123;</span><br><span class="line">       int pivot &#x3D; nums[right];</span><br><span class="line">       int lt &#x3D; left - 1, rt &#x3D; right;</span><br><span class="line">       int i &#x3D; left;</span><br><span class="line">       &#x2F;&#x2F; lt,rt的定义是小于pivot和大于pivot的值的 实边界</span><br><span class="line">       while (i &lt; rt) &#123;</span><br><span class="line">           int num &#x3D; nums[i];</span><br><span class="line">           if (num &lt; pivot) &#123;</span><br><span class="line">               swap(nums, i , ++lt);</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           else if (num &gt; pivot) &#123;</span><br><span class="line">               swap(nums, i, --rt);</span><br><span class="line">           &#125;</span><br><span class="line">           else &#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       swap(nums, right, rt++);</span><br><span class="line">       int[] bound &#x3D; new int[2];</span><br><span class="line">       bound[0] &#x3D; lt;</span><br><span class="line">       bound[1] &#x3D; rt;</span><br><span class="line">       return bound;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>分治算法 – 计算的过程主要在合并中。</p><p>归并排序应用在计算逆序对中的例子。需要注意的是归并排序需要<strong>额外空间</strong>来维护排序过程中的左右序列下标i,j的语义，也因此，它视为out-place排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private int mergeAndCount(int[] nums, int left, int mid, int right, int[] temp) &#123;</span><br><span class="line">       &#x2F;&#x2F; 复制到辅助数组里，帮助我们完成统计</span><br><span class="line">       for (int i &#x3D; left; i &lt;&#x3D; right; i++) &#123;</span><br><span class="line">           temp[i] &#x3D; nums[i];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int i &#x3D; left;</span><br><span class="line">       int j &#x3D; mid + 1;</span><br><span class="line">       int res &#x3D; 0;</span><br><span class="line">       for (int k &#x3D; left; k &lt;&#x3D; right; k++) &#123;</span><br><span class="line">           if (i &gt; mid) &#123;</span><br><span class="line">               &#x2F;&#x2F; i 用完了，只能用 j</span><br><span class="line">               nums[k] &#x3D; temp[j];</span><br><span class="line">               j++;</span><br><span class="line">           &#125; else if (j &gt; right) &#123;</span><br><span class="line">               &#x2F;&#x2F; j 用完了，只能用 i</span><br><span class="line">               nums[k] &#x3D; temp[i];</span><br><span class="line">               i++;</span><br><span class="line">           &#125; else if (temp[i] &lt;&#x3D; temp[j]) &#123;  </span><br><span class="line">               &#x2F;&#x2F; 此时前数组元素出列，不统计逆序对</span><br><span class="line">               nums[k] &#x3D; temp[i];</span><br><span class="line">               i++;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F; 此时后数组元素出列，统计逆序对，快就快在这里，一次可以统计出一个区间的个数的逆序对</span><br><span class="line">               nums[k] &#x3D; temp[j];</span><br><span class="line">               j++;</span><br><span class="line">               res +&#x3D; (mid - i + 1);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>针对近乎有序的数组，在merge前可以判断一下list1的尾巴和list2的头，如果符合有序性那么就可以不merge了。</p><p>在即将排序完成时，可以转而使用插入排序。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>并行排序、求逆序对。</p><h3 id="本章节知识体系与复习思路"><a href="#本章节知识体系与复习思路" class="headerlink" title="本章节知识体系与复习思路"></a>本章节知识体系与复习思路</h3><h4 id="Talk-is-not-cheap"><a href="#Talk-is-not-cheap" class="headerlink" title="Talk is not cheap"></a>Talk is not cheap</h4><ul><li>了解各类排序算法的思想和应用场景，自然就明白其时空复杂度</li><li>熟悉二分思想，尤其明白它如何在跳表和各种二叉搜索树变形中应用</li><li>能解TOP K问题，能用擅长的语言熟练地对任意数据类型排序（例如，在Java中，要会写比较器）</li></ul><h4 id="Show-the-Code"><a href="#Show-the-Code" class="headerlink" title="Show the Code"></a>Show the Code</h4><ul><li>手写floor</li><li>手写三路快排、归并、堆排</li><li>通过TOP K问题（LC 215）、排序（LC 912） 练习</li></ul><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h3><p>对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。（每层结点都完全填满，在最后一层上如果不是满的，则只缺少右边的若干结点。）</p><p>鉴于完全二叉树的性质，它可以很容易地被数组表示，<strong>通过数组下标间关系可以观察到父子关系</strong>。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆不一定是完全二叉树（可以是其他树），使用完全二叉树实现堆是因为易于存储且便于索引。</p><p>常用的是<strong>二叉堆</strong>是具有父结点大于等于/小于等于子结点的完全二叉树。</p><h5 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h5><ol><li>堆化：检查某个非叶子结点是否符合堆特性，在交换完毕之后需要接着递归地去检查交换过后的新结点</li><li>建堆：从最后一个非叶子结点倒序遍历至根节点，每次都进行堆化</li><li>插入：每次在数据末端插入，之后进行siftup()，找到插入结点的父结点并检查父子关系是否需要交换；接着迭代地检查移动后的新插入结点与其父亲的关系</li><li>删除：用最后一个元素替代要删除的元素，接着siftdown() ，类似siftup，直到都符合堆条件</li></ol><p>LC：见<a href="https://cloud.tencent.com/developer/article/1163053整理" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1163053整理</a></p><p>劣势：</p><ol><li>对复杂数据的swap开销较大</li><li>建堆前和建堆后，难以找到原先位置的元素。比方说，想找原来索引值为6的元素，建堆后就只能遍历找了。</li></ol><h5 id="索引堆"><a href="#索引堆" class="headerlink" title="索引堆"></a>索引堆</h5><p>建立两个数组，树索引 -&gt; 原始数据; 树索引 -&gt; 建堆后的元素索引。想找建堆后的数据就从 树索引-&gt; 建堆后的元素索引号-&gt; 数据。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\shy\AppData\Roaming\Typora\typora-user-images\image-20200416150548989.png" alt="image-20200416150548989" title="">                </div>                <div class="image-caption">image-20200416150548989</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\shy\AppData\Roaming\Typora\typora-user-images\image-20200416150602565.png" alt="image-20200416150602565" title="">                </div>                <div class="image-caption">image-20200416150602565</div>            </figure><h5 id="实现与应用"><a href="#实现与应用" class="headerlink" title="实现与应用"></a>实现与应用</h5><p>Java类：PriorityQueue</p><p>进程调度的一种实现：优先队列用于选择优先级最高的任务    </p><p>在N个元素中选前M个大元素：O(MlogN)，维护一个最小堆，当元素比最小堆堆顶大时删除堆顶，让它进堆。</p><p>多路归并排序：可以在merge的时候用堆排序</p><p>最大最小队列（同时能找到最大元素和最小元素的优先队列）：利用两个索引堆</p><h3 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h3><ol><li>核心定义：左子树的所有值都比根小，右子树的所有值都比根大，不会有重复索引。用于<strong>有序查找问题</strong>。</li><li>性能，O(logn)-O(n)；性能瓶颈在于极端不平衡的情况；平衡二叉树和红黑树都是它的改进<ol><li><strong>搜索，插入，删除</strong>的复杂度实质上取决于对应结点的深度，二分搜索树的这三个操作效果都不错</li></ol></li><li>查找过程：中序遍历二叉搜索树可以得到一个有序序列</li><li>插入过程：递归插入即可</li><li>删除过程：<ol><li>删叶子：直接删除</li><li>删仅有单子树：删除，子结点替代原本根结点的位置</li><li>删有双子树：用它的直接前驱或者后继A（即左子树的最大结点或右子树的最小结点）替代它，然后再删除A</li></ol></li><li>顺序性：<ol><li>Ceil</li><li>Floor</li><li>Rank（一个元素是排名第几的？/二分搜索树的结点个数）：对每个结点都存以它为根结点的树的结点数，就可以很轻松地算出来</li><li>Select（排名第x的元素是谁？）：使用中序遍历即可得</li></ol></li><li>如何支持重复元素？：为每个node加一个默认为1的count，表示重复的次数</li></ol><h4 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h4><p>AVL：</p><ol><li>对比二叉搜索树的改进之处：控制了两边子树的高度差不大于1 </li><li>性能：时间复杂度都是O(logn)</li><li>缺陷：增加或删除元素的操作需要一次或多次的树旋转，以实现树的重新平衡</li><li>查找、插入、删除过程<ol><li>某根结点的平衡因子：该结点左右子树的高度差；可以直接保存平衡因子，或者保存结点的高度</li><li>四种情况LL RR LR RL<ol><li>LL 右旋</li><li>RR 左旋</li><li>LR 先左后右</li><li>RL 先右后左</li></ol></li><li>查找和二叉搜索树是一样的</li><li>插入和删除之后需要再平衡</li></ol></li></ol><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树（可以认为是一种特殊的平衡二叉搜索树）</p><ol><li>对比二叉搜索树、AVL的改进之处：控制两边子树的高度差不为2倍（最大深度≤最小深度的两倍），控制力度比AVL小。</li><li>性能：类似AVL，不过插入和删除通常比AVL快，但是在查询频繁的环境下可能AVL更快，因为AVL的结点平均高度比较小。每个结点会占用更多的空间。</li><li>性质：（作为2-3-4树的一种等价）<ol><li>结点带黑色或是红色</li><li>根结点，叶子结点是黑色</li><li>红色结点的子结点是黑色（没有父子都红）</li><li>从任意结点到叶子结点的路径都包含了数量相同的黑结点</li></ol></li><li>构建、查找、插入、删除过程：<ol><li>自平衡过程：<ol><li>左旋：旋转点N的右结点R作为父结点，R的左结点作为N的新右结点</li><li>右旋：旋转点N的左结点L作为父结点，L的右结点作为N的新左结点</li><li>变色：变色以符合红黑树性质</li></ol></li><li>插入/删除：查找-&gt;自平衡 ，具体见<a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">https://www.jianshu.com/p/e136ec79235c</a></li></ol></li></ol><h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>trie树：</p><ol><li>用于前缀匹配（例如在搜索引擎中）。利用所有字符串构建trie树，然后输出以target为开头的树即可</li></ol><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>至少了解以下应用：</p><ul><li>avl树“windows对进程地址空间的管理”</li><li>红黑树（linux中ext3文件系统管理），（JAVA的HashMap的底层实现）</li><li>B树（数据库）（文件系统） -》确定是哪类数据库和哪类文件系统</li><li>哈夫曼树：给定n权值作为n个叶子节点，构造一棵二叉树，若这棵二叉树的<strong>带权路径长度达到最小</strong>，则称这样的二叉树为最优二叉树，也称为Huffman树。（节点的带权路径长度：从该节点到树根之间的路径长度与节点上权的乘积。）<ol><li>应用于通信中对信息的二进制编码。令所有字符都位于叶子结点，出现次数多的字符与根的路径长度最短，这样来降低开销。</li><li>建树方法：按出现的频率（权值）从小到大建树，父结点的权值为子结点之和。</li></ol></li></ul><h3 id="本章节知识体系与复习思路-1"><a href="#本章节知识体系与复习思路-1" class="headerlink" title="本章节知识体系与复习思路"></a>本章节知识体系与复习思路</h3><h4 id="Talk-is-not-cheap-1"><a href="#Talk-is-not-cheap-1" class="headerlink" title="Talk is not cheap"></a>Talk is not cheap</h4><ul><li>理解BFS和DFS的思想和侧重的问题，应用思想到二叉树的遍历中</li><li>熟悉并且会利用二叉树的性质（例如完全二叉树父结点与子结点的关系，例如结点数目、分支数和叶子结点数目的数学关系）</li><li>熟悉堆排序（maxheapify）</li><li>了解三种平衡二叉树的变体的应用场景（AVL、B+、红黑）</li></ul><h4 id="Show-the-Code-1"><a href="#Show-the-Code-1" class="headerlink" title="Show the Code"></a>Show the Code</h4><ol><li>会写二叉树的三种遍历，包括中序和前序的非递归形式</li><li></li></ol><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>跳表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://lotabout.me/2018/skip-list/skip-list-back-search.svg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><ol><li>定义：首先，跳表处理的是有序的链表（一般是双向链表）。底层存储全部得结点，每上一层，结点减少一半。搜索时优先搜索上层，然后定位到下层。</li><li>优势：维持结构平衡的成本很低，完全依赖随机。</li><li>查询，插入，删除的时间复杂度都是O(log N)，占用的空间为O(2N)</li><li>插入与删除时给链表升降层：随机选择新节点是否提拔，默认概率50%</li><li>应用：redis、leveldb</li></ol><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p><a href="https://brilliant.org/wiki/catalan-numbers/" target="_blank" rel="noopener">https://brilliant.org/wiki/catalan-numbers/</a></p><p><a href="https://www.zhihu.com/question/25072237/answer/30111179" target="_blank" rel="noopener">https://www.zhihu.com/question/25072237/answer/30111179</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic3.zhimg.com/80/a8b68a1d18745675f597e7a57a07964a_1440w.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><ol><li>对（k，k+1）将路线分为两部分，后半部分可以将矩阵旋转</li><li>观察(0,0)到(n - 1, n + 1)，必定经过(k, k+ 1)</li><li>故可以求出超过对角线的值</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\shy\AppData\Roaming\Typora\typora-user-images\image-20200430101623936.png" alt="image-20200430101623936" title="">                </div>                <div class="image-caption">image-20200430101623936</div>            </figure><h1 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h1><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ol><li>明确问题（输入-&gt;输出，类型与范围限制）</li><li>想到一个合适的算法<ol><li>观察大致的思路，拆解问题，转化成自己解决过的问题</li><li>或者从暴力法优化</li></ol></li><li>Coding：<ol><li>确定大概的逻辑，光速写下注释</li><li>确定每个变量的定义，并在算法中维护它</li></ol></li><li>Debug &amp; Test<ol><li>小数据量调试</li><li>边际条件调试</li></ol></li></ol><h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>得到大致的时空复杂度并不困难，要达到合格的标准应至少能手推 建堆（而不是堆排序） 的时空复杂度。</p><h3 id="海量数据问题"><a href="#海量数据问题" class="headerlink" title="海量数据问题"></a>海量数据问题</h3><p>难点：</p><ul><li>存储空间不足以一次容纳所有数据</li><li>传统方法应对海量数据可能过于耗时</li></ul><p><a href="https://juejin.im/entry/5a27cb796fb9a045104a5e8c" target="_blank" rel="noopener">https://juejin.im/entry/5a27cb796fb9a045104a5e8c</a></p><p>基本解决方案：</p><ul><li>分治（值域分治/实际数据分治）+Hash</li><li>位图：用更小的容量来表示每个数据的情况</li><li>Trie树：适用于数据量大、重复多、但是数据种类少的情况。例如各种词频统计</li><li>MapReduce：一种分布式处理方案</li></ul><ol><li>在2.5亿个整数中找到不重复的整数。<ol><li>分治法+HashMap：将数组分为多批（对数据进行划分或者对数值范围进行划分都是可行的），每批维护HashMap（key为整数，value为出现的次数）。每批处理完之后清洗不合法的key。</li><li>位图存储：使用更精简的存储方式来维护整数和它的对应情况。2.5亿个数，每个数可以维护三个情况（1：没有；2：出现一次；3：出现多次），可以用2bit维护它的情况。2.5亿个数耗內存1GB，可以接受。</li></ol></li><li>海量日志数据：提取出某日访问淘宝次数最多的IP<ol><li>不一样的分治+Hash：这次是对IP范围进行分治，利用Hash映射一次读入一个范围的IP，然后对其进行次数分析，最大堆排序；保存堆顶，在全部IP范围处理完之后，对比堆顶就可以得到结果了。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;h2 id=&quot;查找与排序&quot;&gt;&lt;a href=&quot;#查找与排序&quot; class=&quot;headerlink&quot; title=&quot;查找与排序&quot;&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/04/14/hello-world/"/>
    <id>http://yoursite.com/2020/04/14/hello-world/</id>
    <published>2020-04-14T08:39:48.767Z</published>
    <updated>2020-04-14T08:39:48.767Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
