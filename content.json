[{"title":"数据结构与算法","date":"2020-05-10T12:29:40.785Z","path":"2020/05/10/数据结构与算法/","text":"数据结构查找与排序二分查找 二分查找，要熟悉迭代与非迭代的写法， 以及对各种边际条件的考量 变种：可以使用floor和ceil确定它的上下界 当存在大量重复的元素时，floor找的是第一个，ceil找的是第一个。 当不存在指定的元素时，floor是比其小最大的一个，而ceil是比其大最小的一个。 算法：先找到对应值，然后再使用二分查找寻找上下界（floor或ceil可作为二分的巩固练习） 二分查找的应用 跳表（基于链表的二分查找），redis的有序集合 二叉搜索树 有序序列 快排、归并、堆排 JAVA源生查找算法 Arrays.binarySearch(list,key); Collections.binarySearch(List sList, T key, Comparator C) :根据是否实现了Comparable接口 进阶：基于搜索下标空间的二分和基于值范围的二分：求数组中第n大的元素 基于值的二分：当重复值较少且值的范围不大时，可以对值域进行二分查找。在这个问题中各方面来看都不是个好方法，不过要知道思路。 常规的二分思路的应用，在这里是快排partition思想的应用，partition的特点是每次能确定pivot的绝对位置并约束其左右序列的值域，应用在搜索中就是快速选择算法，平均时间复杂度O(n)，最坏时间复杂度O(n^2)，一般来说是一种很好的无序查找第k元素的方法。 快速选择与三路快排：https://leetcode-cn.com/problems/wiggle-sort-ii/ Partition 的两种版本：见LC 215 交替赋值法 交换法（不使用while(true)的版本) 排序 十种排序算法 （最坏、平均、最优）时间复杂度、空间复杂度 image-20200309194909228 排序稳定性的意义1. 对于int[]，确实意义不大；但对于复杂对象，**原始数据的相对关系**可能具有更深的逻辑意义；例如按身高排序，体重的相对关系不应该变化 1. 因此，源生的排序算法，对基本类型是（三路）快排，而复杂类型则是归并排序保证稳定性 哪几种排序支持并行？ 冒泡排序-》奇偶排序，可并行 归并排序-&gt;基于msg的分布式系统。比较特殊，在各自的机器内使用快排排好，然后再merge。 快速排序 img 分治算法——侧重于分。 观察快排递归树，二路快排对大于等于是一样的处理，这意味着在重复值较多的情况下，快排递归树会极度不平衡。 为此而生的就是三路快排,以下是它的parition实现。 image-20200414185401728 1234567891011121314151617181920212223242526&#x2F;&#x2F;Key：明晰并维护变量的逻辑含义&#x2F;&#x2F; left，right都表示partition范围的实边界public int[] partition(int[] nums, int left, int right) &#123; int pivot &#x3D; nums[right]; int lt &#x3D; left - 1, rt &#x3D; right; int i &#x3D; left; &#x2F;&#x2F; lt,rt的定义是小于pivot和大于pivot的值的 实边界 while (i &lt; rt) &#123; int num &#x3D; nums[i]; if (num &lt; pivot) &#123; swap(nums, i , ++lt); i++; &#125; else if (num &gt; pivot) &#123; swap(nums, i, --rt); &#125; else &#123; i++; &#125; &#125; swap(nums, right, rt++); int[] bound &#x3D; new int[2]; bound[0] &#x3D; lt; bound[1] &#x3D; rt; return bound; &#125; 归并排序分治算法 – 计算的过程主要在合并中。 归并排序应用在计算逆序对中的例子。需要注意的是归并排序需要额外空间来维护排序过程中的左右序列下标i,j的语义，也因此，它视为out-place排序。 12345678910111213141516171819202122232425262728293031private int mergeAndCount(int[] nums, int left, int mid, int right, int[] temp) &#123; &#x2F;&#x2F; 复制到辅助数组里，帮助我们完成统计 for (int i &#x3D; left; i &lt;&#x3D; right; i++) &#123; temp[i] &#x3D; nums[i]; &#125; int i &#x3D; left; int j &#x3D; mid + 1; int res &#x3D; 0; for (int k &#x3D; left; k &lt;&#x3D; right; k++) &#123; if (i &gt; mid) &#123; &#x2F;&#x2F; i 用完了，只能用 j nums[k] &#x3D; temp[j]; j++; &#125; else if (j &gt; right) &#123; &#x2F;&#x2F; j 用完了，只能用 i nums[k] &#x3D; temp[i]; i++; &#125; else if (temp[i] &lt;&#x3D; temp[j]) &#123; &#x2F;&#x2F; 此时前数组元素出列，不统计逆序对 nums[k] &#x3D; temp[i]; i++; &#125; else &#123; &#x2F;&#x2F; 此时后数组元素出列，统计逆序对，快就快在这里，一次可以统计出一个区间的个数的逆序对 nums[k] &#x3D; temp[j]; j++; res +&#x3D; (mid - i + 1); &#125; &#125; return res; &#125; 优化针对近乎有序的数组，在merge前可以判断一下list1的尾巴和list2的头，如果符合有序性那么就可以不merge了。 在即将排序完成时，可以转而使用插入排序。 应用并行排序、求逆序对。 本章节知识体系与复习思路Talk is not cheap 了解各类排序算法的思想和应用场景，自然就明白其时空复杂度 熟悉二分思想，尤其明白它如何在跳表和各种二叉搜索树变形中应用 能解TOP K问题，能用擅长的语言熟练地对任意数据类型排序（例如，在Java中，要会写比较器） Show the Code 手写floor 手写三路快排、归并、堆排 通过TOP K问题（LC 215）、排序（LC 912） 练习 树满二叉树与完全二叉树对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。（每层结点都完全填满，在最后一层上如果不是满的，则只缺少右边的若干结点。） 鉴于完全二叉树的性质，它可以很容易地被数组表示，通过数组下标间关系可以观察到父子关系。 堆堆不一定是完全二叉树（可以是其他树），使用完全二叉树实现堆是因为易于存储且便于索引。 常用的是二叉堆是具有父结点大于等于/小于等于子结点的完全二叉树。 核心操作 堆化：检查某个非叶子结点是否符合堆特性，在交换完毕之后需要接着递归地去检查交换过后的新结点 建堆：从最后一个非叶子结点倒序遍历至根节点，每次都进行堆化 插入：每次在数据末端插入，之后进行siftup()，找到插入结点的父结点并检查父子关系是否需要交换；接着迭代地检查移动后的新插入结点与其父亲的关系 删除：用最后一个元素替代要删除的元素，接着siftdown() ，类似siftup，直到都符合堆条件 LC：见https://cloud.tencent.com/developer/article/1163053整理 劣势： 对复杂数据的swap开销较大 建堆前和建堆后，难以找到原先位置的元素。比方说，想找原来索引值为6的元素，建堆后就只能遍历找了。 索引堆建立两个数组，树索引 -&gt; 原始数据; 树索引 -&gt; 建堆后的元素索引。想找建堆后的数据就从 树索引-&gt; 建堆后的元素索引号-&gt; 数据。 image-20200416150548989 image-20200416150602565 实现与应用Java类：PriorityQueue 进程调度的一种实现：优先队列用于选择优先级最高的任务 在N个元素中选前M个大元素：O(MlogN)，维护一个最小堆，当元素比最小堆堆顶大时删除堆顶，让它进堆。 多路归并排序：可以在merge的时候用堆排序 最大最小队列（同时能找到最大元素和最小元素的优先队列）：利用两个索引堆 二分搜索树 核心定义：左子树的所有值都比根小，右子树的所有值都比根大，不会有重复索引。用于有序查找问题。 性能，O(logn)-O(n)；性能瓶颈在于极端不平衡的情况；平衡二叉树和红黑树都是它的改进 搜索，插入，删除的复杂度实质上取决于对应结点的深度，二分搜索树的这三个操作效果都不错 查找过程：中序遍历二叉搜索树可以得到一个有序序列 插入过程：递归插入即可 删除过程： 删叶子：直接删除 删仅有单子树：删除，子结点替代原本根结点的位置 删有双子树：用它的直接前驱或者后继A（即左子树的最大结点或右子树的最小结点）替代它，然后再删除A 顺序性： Ceil Floor Rank（一个元素是排名第几的？/二分搜索树的结点个数）：对每个结点都存以它为根结点的树的结点数，就可以很轻松地算出来 Select（排名第x的元素是谁？）：使用中序遍历即可得 如何支持重复元素？：为每个node加一个默认为1的count，表示重复的次数 AVLAVL： 对比二叉搜索树的改进之处：控制了两边子树的高度差不大于1 性能：时间复杂度都是O(logn) 缺陷：增加或删除元素的操作需要一次或多次的树旋转，以实现树的重新平衡 查找、插入、删除过程 某根结点的平衡因子：该结点左右子树的高度差；可以直接保存平衡因子，或者保存结点的高度 四种情况LL RR LR RL LL 右旋 RR 左旋 LR 先左后右 RL 先右后左 查找和二叉搜索树是一样的 插入和删除之后需要再平衡 B+树红黑树红黑树（可以认为是一种特殊的平衡二叉搜索树） 对比二叉搜索树、AVL的改进之处：控制两边子树的高度差不为2倍（最大深度≤最小深度的两倍），控制力度比AVL小。 性能：类似AVL，不过插入和删除通常比AVL快，但是在查询频繁的环境下可能AVL更快，因为AVL的结点平均高度比较小。每个结点会占用更多的空间。 性质：（作为2-3-4树的一种等价） 结点带黑色或是红色 根结点，叶子结点是黑色 红色结点的子结点是黑色（没有父子都红） 从任意结点到叶子结点的路径都包含了数量相同的黑结点 构建、查找、插入、删除过程： 自平衡过程： 左旋：旋转点N的右结点R作为父结点，R的左结点作为N的新右结点 右旋：旋转点N的左结点L作为父结点，L的右结点作为N的新左结点 变色：变色以符合红黑树性质 插入/删除：查找-&gt;自平衡 ，具体见https://www.jianshu.com/p/e136ec79235c Trie树trie树： 用于前缀匹配（例如在搜索引擎中）。利用所有字符串构建trie树，然后输出以target为开头的树即可 线段树应用至少了解以下应用： avl树“windows对进程地址空间的管理” 红黑树（linux中ext3文件系统管理），（JAVA的HashMap的底层实现） B树（数据库）（文件系统） -》确定是哪类数据库和哪类文件系统 哈夫曼树：给定n权值作为n个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉树，也称为Huffman树。（节点的带权路径长度：从该节点到树根之间的路径长度与节点上权的乘积。） 应用于通信中对信息的二进制编码。令所有字符都位于叶子结点，出现次数多的字符与根的路径长度最短，这样来降低开销。 建树方法：按出现的频率（权值）从小到大建树，父结点的权值为子结点之和。 本章节知识体系与复习思路Talk is not cheap 理解BFS和DFS的思想和侧重的问题，应用思想到二叉树的遍历中 熟悉并且会利用二叉树的性质（例如完全二叉树父结点与子结点的关系，例如结点数目、分支数和叶子结点数目的数学关系） 熟悉堆排序（maxheapify） 了解三种平衡二叉树的变体的应用场景（AVL、B+、红黑） Show the Code 会写二叉树的三种遍历，包括中序和前序的非递归形式 跳表跳表 img 定义：首先，跳表处理的是有序的链表（一般是双向链表）。底层存储全部得结点，每上一层，结点减少一半。搜索时优先搜索上层，然后定位到下层。 优势：维持结构平衡的成本很低，完全依赖随机。 查询，插入，删除的时间复杂度都是O(log N)，占用的空间为O(2N) 插入与删除时给链表升降层：随机选择新节点是否提拔，默认概率50% 应用：redis、leveldb 图论组合数学卡特兰数https://brilliant.org/wiki/catalan-numbers/ https://www.zhihu.com/question/25072237/answer/30111179 img 对（k，k+1）将路线分为两部分，后半部分可以将矩阵旋转 观察(0,0)到(n - 1, n + 1)，必定经过(k, k+ 1) 故可以求出超过对角线的值 image-20200430101623936 应用基本思路 明确问题（输入-&gt;输出，类型与范围限制） 想到一个合适的算法 观察大致的思路，拆解问题，转化成自己解决过的问题 或者从暴力法优化 Coding： 确定大概的逻辑，光速写下注释 确定每个变量的定义，并在算法中维护它 Debug &amp; Test 小数据量调试 边际条件调试 时空复杂度得到大致的时空复杂度并不困难，要达到合格的标准应至少能手推 建堆（而不是堆排序） 的时空复杂度。 海量数据问题难点： 存储空间不足以一次容纳所有数据 传统方法应对海量数据可能过于耗时 https://juejin.im/entry/5a27cb796fb9a045104a5e8c 基本解决方案： 分治（值域分治/实际数据分治）+Hash 位图：用更小的容量来表示每个数据的情况 Trie树：适用于数据量大、重复多、但是数据种类少的情况。例如各种词频统计 MapReduce：一种分布式处理方案 在2.5亿个整数中找到不重复的整数。 分治法+HashMap：将数组分为多批（对数据进行划分或者对数值范围进行划分都是可行的），每批维护HashMap（key为整数，value为出现的次数）。每批处理完之后清洗不合法的key。 位图存储：使用更精简的存储方式来维护整数和它的对应情况。2.5亿个数，每个数可以维护三个情况（1：没有；2：出现一次；3：出现多次），可以用2bit维护它的情况。2.5亿个数耗內存1GB，可以接受。 海量日志数据：提取出某日访问淘宝次数最多的IP 不一样的分治+Hash：这次是对IP范围进行分治，利用Hash映射一次读入一个范围的IP，然后对其进行次数分析，最大堆排序；保存堆顶，在全部IP范围处理完之后，对比堆顶就可以得到结果了。","tags":[]},{"title":"Hello World","date":"2020-04-14T08:39:48.767Z","path":"2020/04/14/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]